{"ast":null,"code":"import _classCallCheck from \"C:\\\\Projetos Dev\\\\WebChat\\\\WebChat\\\\webchat.frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Projetos Dev\\\\WebChat\\\\WebChat\\\\webchat.frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { TextMessageFormat } from \"./TextMessageFormat\";\nimport { isArrayBuffer } from \"./Utils\";\n/** @private */\n\nexport var HandshakeProtocol = /*#__PURE__*/function () {\n  function HandshakeProtocol() {\n    _classCallCheck(this, HandshakeProtocol);\n  }\n\n  _createClass(HandshakeProtocol, [{\n    key: \"writeHandshakeRequest\",\n    // Handshake request is always JSON\n    value: function writeHandshakeRequest(handshakeRequest) {\n      return TextMessageFormat.write(JSON.stringify(handshakeRequest));\n    }\n  }, {\n    key: \"parseHandshakeResponse\",\n    value: function parseHandshakeResponse(data) {\n      var messageData;\n      var remainingData;\n\n      if (isArrayBuffer(data)) {\n        // Format is binary but still need to read JSON text from handshake response\n        var binaryData = new Uint8Array(data);\n        var separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\n\n        if (separatorIndex === -1) {\n          throw new Error(\"Message is incomplete.\");\n        } // content before separator is handshake response\n        // optional content after is additional messages\n\n\n        var responseLength = separatorIndex + 1;\n        messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\n        remainingData = binaryData.byteLength > responseLength ? binaryData.slice(responseLength).buffer : null;\n      } else {\n        var textData = data;\n\n        var _separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\n\n        if (_separatorIndex === -1) {\n          throw new Error(\"Message is incomplete.\");\n        } // content before separator is handshake response\n        // optional content after is additional messages\n\n\n        var _responseLength = _separatorIndex + 1;\n\n        messageData = textData.substring(0, _responseLength);\n        remainingData = textData.length > _responseLength ? textData.substring(_responseLength) : null;\n      } // At this point we should have just the single handshake message\n\n\n      var messages = TextMessageFormat.parse(messageData);\n      var response = JSON.parse(messages[0]);\n\n      if (response.type) {\n        throw new Error(\"Expected a handshake response from the server.\");\n      }\n\n      var responseMessage = response; // multiple messages could have arrived with handshake\n      // return additional data to be parsed as usual, or null if all parsed\n\n      return [remainingData, responseMessage];\n    }\n  }]);\n\n  return HandshakeProtocol;\n}();","map":null,"metadata":{},"sourceType":"module"}